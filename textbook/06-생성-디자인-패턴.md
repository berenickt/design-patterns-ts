생성 디자인 패턴은 기존 코드의 유연성과 재사용을 증가시키는 객체를 생성하는 다양한 방법을 제공합니다.

---

# 1. 팩토리 메서드

![design-patterns-ts-6-1](img/design-patterns-ts-6-1.png)

* 객체 생성을 `공장(Factory) 클래스`로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴
  * `부모 클래스`에서 **객체들을 생성할 수 있는 인터페이스를 제공**하지만,
  * `자식 클래스들`이 **생성될 객체들의 유형을 변경할 수 있도록** 하는 생성 패턴
* 즉, 클라이언트에서 직접 `new 연산자`를 통해 제품 객체를 생성하는 것이 아닌, 
  * 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 
  * 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임지는 것이다
* 또한 객체 생성에 필요한 과정을 템플릿 처럼 미리 구성해놓고, 
  * 객체 생성에 관한 전처리나 후처리를 통해 생성 과정을 다양하게 처리하여, 
  * 객체를 유연하게 정할 수 있는 특징도 있다

------

## 1.1 구조

![design-patterns-ts-6-2](img/design-patterns-ts-6-2.png)

1. `Creator` : 최상위 공장 클래스로서, 팩토리 메서드를 추상화하여 서브 클래스로 하여금 구현하도로 함
   - `객체 생성 처리 메서드(someOperartion)` : 객체 생성에 관한 전처리, 후처리를 템플릿화한 메소드
   - `팩토리 메서드(createProduct)` : 서브 공장 클래스에서 재정의할 객체 생성 추상 메서드
2. `ConcreteCreator` : 각 서브 공장 클래스들은 이에 맞는 제품 객체를 반환하도록 생성 추상 메소드를 재정의한다. 
   - 즉, 제품 객체 하나당 그에 걸맞는 생산 공장 객체가 위치된다.
3. `Product` : 제품 구현체를 추상화
4. `ConcreteProduct` : 제품 구현체

> 💡 정리하면,
>
> `팩토리 메소드 패턴`은 `객체를 만들어내는 공장(Factory 객체)을 만드는 패턴`이라고 보면 된다. 
>그리고 어떤 클래스의 인스턴스를 만들지는 미리 정의한 공장 서브 클래스에서 결정한다.

------

## 1.2 적용 시기

* 클래스 생성과 사용의 처리 로직을 분리하여 결합도를 낮추고자 할 때
* 코드가 동작해야 하는 객체의 유형과 종속성을 캡슐화를 통해 정보 은닉 처리 할 경우
* 라이브러리 혹은 프레임워크 사용자에게 구성 요소를 확장하는 방법을 제공하려는 경우 
* 기존 객체를 재구성하는 대신 기존 객체를 재사용하여 리소스를 절약하고자 하는 경우
  - 상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있다. 그리고 객체 생성 방식의 변화는 해당되는 모든 코드 부분을 변경해야 하는 문제가 발생한다. 
  - 따라서 객체의 생성 코드를 별도의 클래스 / 메서드로 분리 함으로써 객체 생성의 변화에 대해 대비를 하기 위해 팩토리 메서드 패턴을 이용한다고 보면 된다. 
  - 특정 기능의 구현은 별개의 클래스로 제공되는 것이 바람직한 설계이기 때문이다.

------

## 1.3 패턴 장점

- 생성자(Creator)와 구현 객체(concrete product)의 강한 결합을 피할 수 있다.
- 팩토리 메서드를 통해 객체의 생성 후 공통으로 할 일을 수행하도록 지정해줄 수 있다.
- 캡슐화, 추상화를 통해 생성되는 객체의 구체적인 타입을 감출 수 있다.
- [단일 책임 원칙Visit Website](https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-SRP-단일-책임-원칙) 준수 : 객체 생성 코드를 한 곳 (패키지, 클래스 등)으로 이동하여 코드를 유지보수하기 쉽게 할수 있으므로 원칙을 만족
- [개방/폐쇄 원칙Visit Website](https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-OCP-개방-폐쇄-원칙) 준수 : 기존 코드를 수정하지 않고 새로운 유형의 제품 인스턴스를 프로그램에 도입할 수 있어 원칙을 만족 (확장성 있는 전체 프로젝트 구성이 가능)
- 생성에 대한 인터페이스 부분과 생성에 대한 구현 부분을 따로 나뉘었기 때문에 패키지 분리하여 개별로 여러 개발자가 협업을 통해 개발

![design-patterns-ts-6-3](img/design-patterns-ts-6-3.png)

------

## 1.4 패턴 단점

* 각 제품 구현체마다 팩토리 객체들을 모두 구현해야 되기 때문에, 
  구현체가 늘어날때 마다 팩토리 클래스가 증가하여 서브 클래스 수가 폭발한다.
* 코드의 복잡성이 증가한다.

---

# 2. 추상 팩토리



추상 팩토리는 **관련 객체들의 구상 클래스들을 지정하지 않고도**,
관련 **객체들의 모음을 생성할 수 있도록** 하는 생성패턴입니다.

---

# 3. 빌더 패턴



빌더는 **복잡한 객체들을 단계별로 생성할 수 있도록** 하는 생성 디자인 패턴입니다.
이 패턴을 사용하면 **같은 제작 코드를 사용하여 객체의 다양한 유형들과 표현을 제작**할 수 있습니다.

---

# 4. 프로토타입 패턴



프로토타입은 **코드를 그들의 클래스들에 의존시키지 않고, 기존 객체들을 복사할 수 있도록** 하는 생성 디자인 패턴입니다.

---

# 5. 싱글턴 패턴



싱글턴은 클**래스에 인스턴스가 하나만 있도록 하면서, 이 인스턴스에 대한 전역 접근(액세스) 지점을 제공**하는 생성 디자인 패턴입니다.
